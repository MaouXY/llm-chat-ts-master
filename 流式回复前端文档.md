# Vue 3 AI 流式回复实现教程

## 1. 概述

在现代 AI 聊天应用中，流式回复（Streaming Response）是提升用户体验的关键特性。它允许 AI 在生成完整回复之前，就将部分内容实时传输给用户，避免了用户长时间等待的焦虑感。

本教程将详细讲解如何在 Vue 3 应用中实现 AI 流式回复，基于 Server-Sent Events (SSE) 技术和 ReadableStream API。

## 2. 核心原理

### 2.1 Server-Sent Events (SSE)

SSE 是一种服务器到客户端的单向通信协议，允许服务器主动向客户端发送数据。与 WebSocket 不同，SSE 只支持单向通信，更适合 AI 聊天这种服务器推送场景。

### 2.2 ReadableStream API

ReadableStream API 允许我们逐块读取响应数据，而不需要等待整个响应完成。这是实现流式回复的核心 API。

### 2.3 TextDecoder API

用于将二进制流数据解码为字符串，以便后续处理。

## 3. 实现步骤

### 3.1 准备工作

确保你的项目已经安装了 Vue 3，并且配置了正确的 API 基础 URL。

### 3.2 核心代码结构

在 Vue 组件中，我们需要实现以下关键功能：

1. 发送聊天请求
2. 建立 SSE 连接
3. 处理流式响应
4. 实时更新 UI
5. 处理流结束和错误

### 3.3 详细实现

#### 3.3.1 发送请求与建立连接

```typescript
// 发送消息
const sendMessage = async () => {
  // 表单验证
  if (!inputMessage.value.trim()) {
    Message.warning('请输入消息内容')
    return
  }

  // 如果没有会话ID，先新建会话
  if (!sessionId.value) {
    await createNewSession()
  }

  // 添加用户消息到聊天记录
  const userMessage = {
    role: 'user',
    content: inputMessage.value,
    timestamp: currentTime.value
  }
  messages.value.push(userMessage)

  // 保存聊天记录到localStorage
  saveMessagesToLocalStorage()

  // 清空输入框
  const message = inputMessage.value
  inputMessage.value = ''

  // 添加AI回复占位符
  const aiMessageIndex = messages.value.length
  const aiMessage = {
    role: 'ai',
    content: '',
    timestamp: currentTime.value
  }
  messages.value.push(aiMessage)

  // 确保聊天区域滚动到底部
  setTimeout(() => {
    const chatContainer = document.querySelector('.max-h-96')
    if (chatContainer) {
      chatContainer.scrollTop = chatContainer.scrollHeight
    }
  }, 0)

  loading.value = true
  try {
    // 获取token
    const token = localStorage.getItem('token')
    if (!token) {
      throw new Error('未找到token，请重新登录')
    }

    // 构建聊天请求数据
    const chatRequest: ChatRequest = {
      prompt: message,
      history: messages.value.slice(0, -1).map(msg => ({
        role: msg.role,
        content: msg.content
      }))
    }

    const requestData = {
      bookName: discussionBook.value,
      sessionId: sessionId.value,
      chatRequest,
      aiPartnerId: selectedPartner.id as number
    }

    // 使用fetch API处理SSE连接
    const response = await fetch(`${import.meta.env.VITE_API_BASE_URL}/lit-chat/send/stream`, {
      method: 'POST',
      headers: {
        'Authorization': `${token}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify(requestData)
    })

    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`)
    }

    // 获取可读流
    const reader = response.body?.getReader()
    if (!reader) {
      throw new Error('无法获取响应流')
    }
    const decoder = new TextDecoder('utf-8')
    
    // 用于存储未处理的部分数据
    let buffer = ''
    
    // 处理流式响应
    while (true) {
      const { done, value } = await reader.read()
      if (done) {
        break
      }
      
      // 解码数据并添加到缓冲区
      const decodedValue = decoder.decode(value, { stream: true })
      buffer += decodedValue
      
      // 分割SSE事件
      let events = buffer.split(/\n\n/)
      
      // 保留最后一个可能不完整的事件
      buffer = events.pop() || ''
      
      // 处理每个完整的事件
      for (const event of events) {
        if (event.trim()) {
          // 解析SSE事件
          const lines = event.split(/\n/)
          let jsonData = ''
          
          for (const line of lines) {
            const trimmedLine = line.trim()
            if (trimmedLine.startsWith('data:')) {
              // 提取data字段内容，移除开头的'data:'和可能的空格
              let dataContent = trimmedLine.substring(5).trim()
              // 移除可能的重复data:前缀
              while (dataContent.startsWith('data:')) {
                dataContent = dataContent.substring(5).trim()
              }
              // 只有非空内容才添加
              if (dataContent) {
                jsonData += dataContent
              }
            }
          }
          
          // 检查是否是结束信号
          if (jsonData === '[DONE]') {
            // 流结束，退出循环
            break
          }
          
          // 只有非空的jsonData才尝试解析
          if (jsonData) {
            try {
              // 解析JSON数据
              const parsed = JSON.parse(jsonData)
              
              // 提取content字段
              const content = parsed.choices?.[0]?.delta?.content
              
              // 只有非空内容才添加到消息中
              if (content && messages.value[aiMessageIndex]) {
                // 修复可能的Markdown语法问题
                let processedContent = content
                // 将 # # # 转换为 ###，修复标题语法
                processedContent = processedContent.replace(/#\s+#\s+#/g, '###')
                processedContent = processedContent.replace(/#\s+#/g, '##')
                
                // 将解析出的content内容追加到AI回复中
                messages.value[aiMessageIndex].content += processedContent
                
                // 确保聊天区域滚动到底部
                setTimeout(() => {
                  const chatContainer = document.querySelector('.max-h-96')
                  if (chatContainer) {
                    chatContainer.scrollTop = chatContainer.scrollHeight
                  }
                }, 0)
              }
            } catch (e) {
              console.error('JSON解析错误:', e)
              console.error('错误数据:', jsonData)
            }
          }
        }
      }
    }
    
    // 流结束，保存完整聊天记录
    saveMessagesToLocalStorage()
  } catch (error) {
    console.error('发送消息失败:', error)
    // 更新AI消息为错误信息
    if (messages.value[aiMessageIndex]) {
      messages.value[aiMessageIndex].content = `错误: ${error instanceof Error ? error.message : '发送消息失败'}`
      Message.error(error instanceof Error ? error.message : '发送消息失败')
      // 保存错误状态到localStorage
      saveMessagesToLocalStorage()
    }
  } finally {
    loading.value = false
  }
}
```

## 4. 代码解析

### 4.1 发送请求

```typescript
const response = await fetch(`${import.meta.env.VITE_API_BASE_URL}/lit-chat/send/stream`, {
  method: 'POST',
  headers: {
    'Authorization': `${token}`,
    'Content-Type': 'application/json'
  },
  body: JSON.stringify(requestData)
})
```

这里使用 `fetch` API 向服务器发送 POST 请求，指定了 API 端点、认证头和请求体。

### 4.2 获取流读取器

```typescript
const reader = response.body?.getReader()
if (!reader) {
  throw new Error('无法获取响应流')
}
const decoder = new TextDecoder('utf-8')
let buffer = ''
```

通过 `response.body.getReader()` 获取可读流的读取器，使用 `TextDecoder` 将二进制数据解码为字符串，并用 `buffer` 存储未处理的部分数据。

### 4.3 读取流数据

```typescript
while (true) {
  const { done, value } = await reader.read()
  if (done) {
    break
  }
  
  const decodedValue = decoder.decode(value, { stream: true })
  buffer += decodedValue
  // ...
}
```

使用 `while` 循环持续读取流数据，直到 `done` 为 `true` 表示流结束。

### 4.4 处理 SSE 事件

```typescript
// 分割SSE事件
let events = buffer.split(/\n\n/)

// 保留最后一个可能不完整的事件
buffer = events.pop() || ''

// 处理每个完整的事件
for (const event of events) {
  if (event.trim()) {
    // 解析SSE事件
    const lines = event.split(/\n/)
    let jsonData = ''
    
    for (const line of lines) {
      const trimmedLine = line.trim()
      if (trimmedLine.startsWith('data:')) {
        // 提取data字段内容
        let dataContent = trimmedLine.substring(5).trim()
        // 移除可能的重复data:前缀
        while (dataContent.startsWith('data:')) {
          dataContent = dataContent.substring(5).trim()
        }
        if (dataContent) {
          jsonData += dataContent
        }
      }
    }
    // ...
  }
}
```

解析 SSE 事件格式，提取 `data:` 字段内容，并处理可能的重复前缀。

### 4.5 解析 JSON 数据

```typescript
if (jsonData === '[DONE]') {
  // 流结束，退出循环
  break
}

if (jsonData) {
  try {
    const parsed = JSON.parse(jsonData)
    const content = parsed.choices?.[0]?.delta?.content
    
    if (content && messages.value[aiMessageIndex]) {
      // 修复Markdown语法
      let processedContent = content
      processedContent = processedContent.replace(/#\s+#\s+#/g, '###')
      processedContent = processedContent.replace(/#\s+#/g, '##')
      
      // 更新AI消息
      messages.value[aiMessageIndex].content += processedContent
      
      // 滚动到底部
      setTimeout(() => {
        const chatContainer = document.querySelector('.max-h-96')
        if (chatContainer) {
          chatContainer.scrollTop = chatContainer.scrollHeight
        }
      }, 0)
    }
  } catch (e) {
    console.error('JSON解析错误:', e)
    console.error('错误数据:', jsonData)
  }
}
```

解析 JSON 数据，提取 AI 回复内容，修复 Markdown 语法问题，并实时更新 UI。

### 4.6 流结束处理

```typescript
// 流结束，保存完整聊天记录
saveMessagesToLocalStorage()
```

流结束后，保存完整聊天记录到 localStorage。

## 5. 关键技术点

### 5.1 SSE 事件格式

SSE 事件通常包含 `data:` 前缀，多个 `data:` 字段可以组合成一个完整的事件。事件之间用两个换行符 `\n\n` 分隔。

### 5.2 缓冲区管理

由于流数据是分段到达的，需要使用缓冲区存储未处理的部分数据，确保完整事件的正确解析。

### 5.3 实时 UI 更新

利用 Vue 3 的响应式系统，当 `messages` 数组更新时，UI 会自动刷新，实现实时聊天效果。

### 5.4 错误处理

需要处理各种可能的错误，包括网络错误、JSON 解析错误等，并向用户提供友好的错误提示。

### 5.5 Markdown 渲染

使用 `markdown-it` 库将 AI 回复的 Markdown 文本转换为 HTML，提升回复的可读性。

```typescript
// 创建Markdown解析实例
const md = new MarkdownIt({
  html: true, // 允许HTML标签
  linkify: true, // 自动链接
  typographer: true, // 启用排版规则
})

// Markdown渲染函数
const renderMarkdown = (content: string): string => {
  return md.render(content)
}
```

## 6. 优化建议

### 6.1 增加重连机制

在网络不稳定的情况下，SSE 连接可能会中断。可以添加重连机制，提高系统的鲁棒性。

### 6.2 实现消息暂停/继续功能

允许用户暂停/继续 AI 回复，提升用户控制感。

### 6.3 优化滚动性能

当聊天记录较长时，频繁滚动可能影响性能。可以添加节流或防抖机制。

### 6.4 实现消息类型支持

除了文本消息，还可以支持图片、文件等多种消息类型。

### 6.5 添加打字机效果

为 AI 回复添加打字机效果，进一步提升用户体验。

## 7. 总结

本教程详细讲解了如何在 Vue 3 应用中实现 AI 流式回复，包括核心原理、实现步骤、代码解析和优化建议。通过 Server-Sent Events (SSE) 技术和 ReadableStream API，我们可以实现流畅的 AI 聊天体验，让用户实时看到 AI 的回复内容。

流式回复是现代 AI 聊天应用的重要特性，它可以显著提升用户体验，减少用户等待时间。希望本教程对你有所帮助，祝你在 AI 应用开发中取得成功！